# 目录

# 正文

## 数据结构

### 数组、链表、哈希表的对比

数组的内存大小固定，不能动态拓展

链表的内存利用率高，大小不固定，拓展灵活

哈希表的缺点：插入数据过多时容易冲突，性能大幅下降

#### 单链表与双链表

双链表利用二分法使数据的查找操作效率提高了一倍，但由于每个节点都多了一个指针，需要占用的空间更大

### 字符串

### 栈 (stack)

后进先出

### 队列（queue）

先进先出

### 二叉树

一个结点含有的子树的个数称为该节点的度，只有一个节点的二叉树的度为0.叶节点就是度为0的节点

#### 遍历方式

- 前序遍历：根节点-左子树-右子树
- 中序遍历：左子树-根节点-右子树
- 后序遍历：左子树-右子树-根节点

#### 满二叉树

除叶节点之外的每个节点都有左右子节点

#### 完全二叉树

除最后一层外，每层的节点数都达到了最大值，只在最后一层上缺少右边的部分节点

#### 二叉查找树

根节点的值小于左子树，大于右子树

#### 平衡二叉查找树 AVL

高度差不超过 1 的二叉查找树

- 二叉查找树中如果出现左子树或右子树完全为空的情况，会大大降低查找效率，AVL 就是为了解决这个问题
- AVL 可以为空树

#### 红黑树

自平衡的二叉查找树，从根到叶节点的最长路径不会超过最短路径的两倍

- 根节点是黑色，从根到每个叶节点的所有路径上不能有两个连续的红色节点
- 同样是为了解决不平衡的二叉查找树的效率问题

#### 最优二叉树 Huffman树

给定 n 权值作为 n 个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉树

- 对应一组权重构造出来的最优二叉树一般不是唯一的
- 最优二叉树中没有度为1的节点
- 路径上权值较大的节点离根较近

#### 求解二叉树中两个节点的最近公共祖先节点

- 若为二叉查找树：首先从根节点开始遍历，如果根节点的值比两个节点的值都大，递归遍历左子树，反之遍历右子树，如果根节点的值比其中一个大比另一个小，则该根节点就是两个节点的最近公共祖先

- 若为普通二叉树，但每个节点含有指向父节点的指针：可以通过指针得到它的所有父节点，看作一个链表，就相当于就两个链表的最近公共节点

- 若为普通二叉树，且不含有指向父节点的指针：从根节点出发分别找出到两个节点的路径，然后遍历两条路径，直到遇到第一个不相同的节点，它前面的那个节点就是两节点的最近公共祖先节点

## 算法

### 排序

#### 快速排序

思路：选一个基准元素，将比它小的元素都放到它左边，比它大的元素都放到它右边

复杂度：取决于递归的深度，在完全无序的情况下效果最好，有序情况下效果最差

- 时间复杂度：最好O(nlogn)，最坏O(n^2)
- 空间复杂度：最好O(logn)，最坏O(n)

#### 冒泡排序

思路：相邻元素两两比较交换顺序

复杂度：

- 时间复杂度：平均O(n^2)，最坏O(n^2)
- 空间复杂度：O(1)

优化方式

- 外层优化：记录当前循环是否发生交换，如果没有发生交换，则排序已经完成
- 内层优化：记录当前循环中最后一次元素交换的位置，该位置之后的元素都已经完成了排序，下一轮循环中无需再进行比较

#### 归并排序

思路：分治策略，将数组不断二分直到只剩一个值，然后排序合并，利用了完全二叉树的性质

复杂度：

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

#### 选择排序

#### 插入排序

#### 希尔排序

#### 堆排序

#### 基数排序

#### 各种排序算法的比较：

排序方法|平均情况|最好情况|最坏情况|辅助空间|稳定性
--|--|--|--|--|--
冒泡排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定
选择排序|O(n^2)|O(n^2)|O(n^2)|O(1)|稳定
插入排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定
希尔排序|O(nlogn)~O(n^2)|O(n^1.3)|O(n^2)|O(1)|不稳定
堆排序|O(nlogn)|O(nlogn)|O(nlogn)|O(1)|不稳定
归并排序|O(nlogn)|O(nlogn)|O(nlogn)|O(n)|稳定
快速排序|O(nlogn)|O(nlogn)|O(n^2)|O(logn)~O(n)|不稳定

从表中看来，堆排序应该是最好的算法，但实际上快速排序是应用最广泛的排序算法，分析如下：

首先，看平均情况最好的是堆排序、归并排序、快速排序三种算法，但经过实验，当数据规模达到1亿的时候，快速排序需要的时间是最小的。堆排序中由于有大量无效比较，在数据规模增长后性能会大幅下降，而且会大量地随机存取数据，而在快排中数据是按照顺序存取的。而归并排序主要是空间占用较多。

[为什么说快速排序是性能最好的排序算法？](https://blog.csdn.net/qq_36770641/article/details/82669788)

#### 系统自带排序实现

对于 JS 来说，数组长度大于10的会采用快排，否则采用插入排序（虽然插入排序的时间复杂度很差，但在数据量很小的情况下影响不大，而且插入排序所需要的常数时间很小，相对于其他排序来说更快）

### 递归与循环

### 分治法、动态规划、贪婪算法

### 分治法

将问题划分成多个独立的子问题，子问题与原问题相同，可以递归求解，会有重复求解的问题

### 动态规划

- 将问题划分为多个包含公共问题的子问题，避免了重复求解公共问题
- 每一步不一定包含上一步的最优解，但一定包含某个局部最优解，因此需要记录之前的所有局部最优解

### 贪婪算法

将问题划分为多个子问题，每一步都选取当前的最优解，每一步都包含上一步的最优解，再之前的则不保留

[算法复习笔记(分治法、动态规划、贪心算法)](https://blog.csdn.net/King_Like_Coding/article/details/51865450)

### 位运算

## 常见面试题

### 数组去重

#### 排序去重

#### ES6 的 Set() 方法

`var unique = (a) => [...new Set(a)]`

#### ES6 的 Map() 方法

```
function unique (arr) {
    const seen = new Map()
    return arr.filter((a) => !seen.has(a) && seen.set(a, 1))
}
```

### 数组扁平化（嵌套数组降维）

#### ES6 的 flat() 方法

#### reduce() 方法递归

### 实现 indexOf 方法

```
function indexFun(array, val) {
  if (!Array.isArray(array)) return;

  let length = array.length;

  for (let i = 0; i < length; i++) {
    if (array[i] === val) {
      return i;
    }
  }

  return -1;
} 
```

### 数组的最大值和最小值

```
var arr = [6, 2, 7, 0, 1];
console.log(Math.max.apply(null, arr));
```

### 有n个元素的无序数组的最小k个数

1. 排序，然后取前k位数
2. 维护一个最大堆，先储存遍历到的前k个数，然后遍历剩下的数，每次都与堆中的最大元素kmax比较，比kmax小就替换它，时间复杂度O(logk)

### 反转单向链表

思路：设置三个变量（pre, current, next），从第一个节点向后遍历

```
var reverseList = function(head) {
    // 判断下变量边界问题
    if (!head || !head.next) return head;
    // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null
    let pre = null;
    let current = head;
    let next;
    // 判断当前节点是否为空
    // 不为空就先获取当前节点的下一节点
    // 然后把当前节点的 next 设为上一个节点
    // 然后把 current 设为下一个节点，pre 设为当前节点
    while(current) {
        next = current.next;
        current.next = pre;
        pre = current;
        current = next;
    }
    return pre;
};
```

JS没有指针，但如果用指针讲的话就是，在头节点放两个指针，指针A走到下一个节点，然后将指针A所在节点指向指针B所在节点，这样一直遍历结束

### 给数字加逗号

正则表达式

### 判断一个字符串是否为回文字符串

