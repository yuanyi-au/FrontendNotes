- [浏览器](#浏览器)
	- [浏览器基本工作原理](#浏览器基本工作原理)
		- [进程](#进程)
		- [死锁](#死锁)
			- [产生死锁的必要条件](#产生死锁的必要条件)
			- [解决死锁的方法](#解决死锁的方法)
	- [浏览器内核](#浏览器内核)
		- [GUI 渲染线程](#gui-渲染线程)
		- [JS 引擎线程](#js-引擎线程)
		- [事件触发线程](#事件触发线程)
		- [定时触发器线程](#定时触发器线程)
		- [异步 http 请求线程](#异步-http-请求线程)
	- [渲染流程](#渲染流程)
	- [浏览器缓存](#浏览器缓存)
		- [缓存位置](#缓存位置)
		- [访问缓存优先级](#访问缓存优先级)
		- [强制缓存 和 协商缓存](#强制缓存-和-协商缓存)
		- [Cache-Control](#cache-control)
		- [Last-Modify](#last-modify)
			- [Etag](#etag)

# 浏览器

## 浏览器基本工作原理

### 进程

操作系统是多进程（允许多个任务同时运行），多线程（允许单个任务分成不同的部分运行）的，且提供协调机制，防止进程和线程之间发生冲突，允许进程和线程之间共享资源

浏览器是多进程的，每次打开一个 tab 页就相当于创建了一个进程，一般浏览器的进程数都有限制，达到限制后浏览器会把新开的进程与之前的进程合并（共用渲染进程）

- 多进程的优点：某一页面进程出问题不会影响其他页面，避免不同页面的权限问题，以及第三方插件的问题
- 多进程的缺点：内存消耗大，不同进程中常常包含相同内容

### 死锁

在多个进程执行过程中因资源争夺而造成的僵持状态，此时若没有干预这些线程就都将无法向前推进

#### 产生死锁的必要条件

- 互斥条件：进程要求对所分配的资源进行排它性控制
- 请求和保持条件：当进程因请求资源而阻塞时，对已经获得的资源保持不放
- 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放
- 环路等待条件：在发生死锁时，必然存在一个进程-资源的环形链

#### 解决死锁的方法

1. 预防死锁

	- 一次性分配所有资源，这样就不会再请求资源了
	- 如果某进程获得了部分资源，但得不到剩下的资源，则释放已有资源（超时放弃）
	- 给资源编号，有序分配

2. 避免死锁

	在进行资源分配前先计算安全性，若安全才进行分配，否则进程等待

	银行家算法 //TODO:

3. 解除死锁

	- 从其他进程中剥夺资源给死锁进程，以解除死锁状态
	- 直接撤销死锁进程，或撤销代价最小的进程直到资源足够接触死锁进程为止

[死锁面试题（什么是死锁，产生死锁的原因及必要条件）](https://blog.csdn.net/hd12370/article/details/82814348)


## 浏览器内核

### GUI 渲染线程

- 负责渲染页面
- 与 JS 线程互斥，因为JS 可以操作 DOM，为了防止渲染结果不可预期，需要两者不同时进行

### JS 引擎线程

- 负责解析执行 JS 脚本
- 单线程
- 与 GUI 线程互斥

为了解决 JS 单线程容易引发的阻塞问题， HTML5 提出了 Web Worker，允许主线程创建 Worker 线程，将一些任务分配给该线程在后台运行。JS 引擎线程与 Worker 线程之间通过 postMessage API 进行通信

### 事件触发线程

- 用来控制事件循环
- JS 引擎执行包含事件的代码块时，会将对应任务添加到事件线程中
- 当事件满足触发条件时，将其放入 JS 引擎所在的执行队列尾部，等待 JS 引擎处理

### 定时触发器线程

- setInterval 与 setTimesout 所在的线程
- 计时完毕后通知事件触发线程

### 异步 http 请求线程

- 在 XMLHttpRequest 连接后通过浏览器新开一个线程请求
- 检测到状态变更时，如果设置有回调函数，异步线程就会产生状态变更事件，将回调放入事件队列中，再由 JS 引擎执行


## 渲染流程

- 构建 DOM ：根据 HTML 渲染 DOM（同一个 HTML 文件得到的DOM 树并不总是一样，浏览器会按照自己的规范来构建）
- 加载次级资源：请求下载图片，CSS，JS 等资源
- JS 的下载与执行：`<script>`
- 样式计算：基于 CSS 选择器解析 CSS 计算每个节点的具体样式值
- 获取布局：遍历 DOM 以及相关元素的计算样式，构建出布局树
- 绘制各元素：遍历布局树，创建绘制记录
- 合成帧：遍历布局树，创建层树，合成器将每一层栅格化然后合成帧（合成器是独立工作的，与主线程无关，非常流畅）


[图解浏览器的基本工作原理](https://zhuanlan.zhihu.com/p/47407398)

[浏览器原理机制](https://www.jianshu.com/p/e05307cf8f6a)

[Web Worker 使用教程](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)


## 浏览器缓存

浏览器会把通过 HTTP 获取的所有资源保存到本地

### 缓存位置

Service Worker

memory cache | disk cache
--|--
缓存到内存中|缓存到磁盘中
退出进程时数据会被清除|退出进程时数据不会被清除

一般用 memory cache 保存 JS 文件

### 访问缓存优先级

1. 在内存中查找
2. 在硬盘中查找
3. 进行网络请求
4. 把获取的资源缓存到本地

### 强制缓存 和 协商缓存

浏览器在请求某一资源时，会先获取该资源缓存的 header 信息，判断是否命中强缓存，若命中则直接从缓存中获取资源信息，不会与服务器进行通信。若没有命中强缓存，浏览器会向服务器发送携带之前获取到的有关缓存的 header 信息，服务器对比相关 header 信息看是否命中协商缓存，若命中则服务器返回新的响应 header 信息更新缓存中对应的 header 信息，告知浏览器可以直接从缓存中获取资源信息，若没有命中协商缓存，则会直接返回最新的资源内容

### Cache-Control

http 1.1 出现的 header 信息

### Last-Modify

标识资源的最后修改时间，浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify。当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify

缺点：短时间内如果资源发生变化，Last-Modified 并不会变化，可以用 Etag 处理

#### Etag

服务器针对资源计算出一串校验码，通过 Etag 返回给客户端，客户端下次请求时带上该值，服务器对比校验，如果相同则不返回资源

[浅谈http中的Cache-Control](https://blog.csdn.net/u012375924/article/details/82806617)

[实践这一次，彻底搞懂浏览器缓存机制](https://segmentfault.com/a/1190000017962411)
