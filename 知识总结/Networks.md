# 目录

# 正文

## OSI 七层模型 与 TCP/IP五层模型

### OSI 七层模型

从下到上：
1. 物理层
2. 数据链路层
3. 网络层：
4. 传输层：
5. 会话层
6. 表示层
7. 应用层：

### TCP/IP 五层模型

从下到上：
1. 物理层
2. 数据链路层：网桥、以太交换机（二层交换机）、网卡（一半在数据链路层一半在物理层）
3. 网络层：路由器、三层交换机
4. 传输层：四层交换机
5. 应用层

## HTTP 与 HTTPS

### HTTP 超文本传输协议

- 无状态协议，明文传输，使用 TCP 传输协议保证传输的可靠性
- 不会保存关于客户的任何信息
- 有两种连接模式，持续连接与非持续连接。持续链接下 TCP 默认不关闭，可以避免每次建立连接三次握手所花费的时间。非持续连接每次请求对象都需要建立一个全新的连接。
- 默认使用80端口
- -HTTP 报文的格式：起始行、首部、主体

### HTTPS 超文本传输安全协议

- 基于HTTP，使用TSL/SSL协议加密信息，不会被窃听
- 提供校验机制，如果信息被篡改通信双方会立刻发现
- 默认使用端口443
#### TSL 传输安全层协议

对称加密和非对称加密结合，数字证书

#### SSL 安全套接字协议

对称算法，公用密钥算法

## DNS 协议

域名系统，提供主机名到 IP 地址的转换服务

DNS 协议运行在 UDP 协议之上，使用53号端口

### 域名的层级结构

主机名.次级域名.顶级域名.根域名

host.sld.tld.root

### DNS 查找过程

1. 在本地 host 文件、DNS 解析器缓存中查找主机 IP 地址
2. 到本地 DNS 服务器中查询
3. 到根域名服务器中查找顶级域名 IP 地址
4. 逐级向下返回直到找到主机 IP 地址

## TCP 三次握手 与 四次挥手

### 三次握手（ TCP 连接的建立）

目的：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
1. 客户端向服务器发送一个 SYN 请求报文段，等待服务器确认
2. 服务器端收到 SYN 后，向客服端发送一个 ACK+SYN 报文确认连接请求
3. 客户端收到确认请求后，也向服务器端发送确认报文，然后客户端与服务器端都进入 ESTABLISHED 状态

### 四次挥手 （TCP 连接的释放）

原因：TCP 连接是全双工通信的，单独一方释放连接只代表自己不能再向对方发送数据，需要双方都确认释放连接才可以

1. 客户端向服务器端发送一个 FIN 报文段，申请断开连接，不再发送数据，此时客户端仍可以接收数据
2. 服务器端接收到客户端的请求后，向客户端发送一个确认报文段，表示以后不再接受客户端发过来的数据。但此时还可以向客户端发送数据
3. 服务器端发送完所有数据后向客户端发送 FIN 报文段，申请断开连接，服务器端不再发送数据
4. 客户端接收到请求后，向服务器端发送一个确认应答，进入 TIME_WAIT 阶段，此阶段将持续一段时间（最大生存时间），如果这段时间内服务端没有重发请求，客户端将进入 CLOSED 状态，如果收到重发请求（确认报文丢失）就重发确认报文段，服务器端在收到确认报文后就会进入 CLOSED 状态

## TCP 协议 与 UDP 协议

### TCP 传输控制协议

- 面向连接，无差错、不丢失、不重复、按序到达的可靠交付
- 首部 20 字节
- 只支持一对一通信

### UDP 用户数据报协议

- 无连接，尽最大努力交付（不可靠）
- 首部 8 字节
- 支持一对一，一对多，多对一，多对多通信
- 实时性高，而且没有拥塞控制与流量控制机制，发送速率没有限制

## 正向代理 与 反向代理

- 正向代理隐藏了真正的请求客户端，服务端只知道代理服务器是谁
- 反向代理隐藏了真正的服务端，客户端只知道代理服务器是谁，一般用来实现负载平衡

## Get 与 Post

浏览器中非 Ajax 的 HTTP 请求

- HTTP 本身是明文协议，所以其实两种都不安全，只是 Get 请求包含在 url 中，会被缓存，能被直接看到，更不安全一点。Post 用报文实体部分传输数据。
- url 有长度限制
- Post 支持更多的编码类型且不限制数据类型
- - Get 一般用于请求网页这样不会对服务器资源产生影响的场景，Post 一般用于注册用户这类会对服务器资源产生影响的场景场景

## cookie 与 session （会话跟踪技术）

HTTP 协议时无状态协议，数据交换完毕后就会关闭客户端与服务器端的连接，意味着服务器无法跟踪会话

### cookie

- 在客户端记录信息确定用户身份
- cookie 具有不可跨域名性
- cookie 由于存放在本地很容易被获取到，不是很安全（cookie 欺骗和 cookie 截获）

### session

- 在服务器端记录信息确定用户身份
- session 在用户第一次访问服务器时自动创建，之后用户如果再次访问，服务器都会更新最后访问时间，维护 session
- 为了防止内存溢出，服务器会把长时间没有活跃的 session 从内存中删除
- session 需要 cookie 作为识别标识
- 子窗口会共享父窗口的 session

## 如何判断用户是否登录

用户输入的密码由 post 请求发送给服务器，服务器将其与自己数据库中的数据对比，不一致则返回信息给客户端，一致则生成一个 session，同时生成的 session ID 作为 cookie 发送给客户端，对比成功后就重定向至登陆前的页面。判断用户是否登录就是通过这个 session ID（session 过期 -> 登陆过期）

## 从 url 输入到页面展现发生了什么

1. 在浏览器中输入 url 
2. 应用层 DNS 解析域名：先本地查找，再查询 DNS 服务器
3. 应用层客户端发送 HTTP 请求
4. 传输层 TCP 传输报文：三次握手
5. 网络层 IP 协议查询 MAC 地址
6. 数据到达数据链路层
7. 服务器接受数据
8. 服务器响应请求
9. 服务器返回相应文件
10. 页面渲染

## 浏览器基本工作原理

### 进程

操作系统是多进程（允许多个任务同时运行），多线程（允许单个任务分成不同的部分运行）的，且提供协调机制，防止进程和线程之间发生冲突，允许进程和线程之间共享资源。

浏览器是多进程的，每次打开一个 tab 页就相当于创建了一个进程，一般浏览器的进程数都有限制，达到限制后浏览器会把新开的进程与之前的进程合并（共用渲染进程）

- 多进程的优点：某一页面进程出问题不会影响其他页面，避免不同页面的权限问题，以及第三方插件的问题
- 多进程的缺点：内存消耗大，不同进程中常常包含相同内容

### 死锁

在多个进程执行过程中因资源争夺而造成的僵持状态，此时若没有干预这些线程就都将无法向前推进。

#### 产生死锁的必要条件

- 互斥条件：进程要求对所分配的资源进行排它性控制
- 请求和保持条件：当进程因请求资源而阻塞时，对已经获得的资源保持不放
- 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放
- 环路等待条件：在发生死锁时，必然存在一个进程-资源的环形链

#### 解决死锁的方法

##### 预防死锁

- 一次性分配所有资源，这样就不会再请求资源了
- 如果某进程获得了部分资源，但得不到剩下的资源，则释放已有资源（超时放弃）
- 给资源编号，有序分配

##### 避免死锁

在进行资源分配前先计算安全性，若安全才进行分配，否则进程等待。

银行家算法 //TODO:

##### 解除死锁

- 从其他进程中剥夺资源给死锁进程，以解除死锁状态
- 直接撤销死锁进程，或撤销代价最小的进程直到资源足够接触死锁进程为止

[死锁面试题（什么是死锁，产生死锁的原因及必要条件）](https://blog.csdn.net/hd12370/article/details/82814348)

### 浏览器内核

#### GUI 渲染线程

- 负责渲染页面
- 与 JS 线程互斥，因为JS 可以操作 DOM，为了防止渲染结果不可预期，需要两者不同时进行

#### JS 引擎线程

- 负责解析执行 JS 脚本
- 单线程
- 与 GUI 线程互斥

为了解决 JS 单线程容易引发的阻塞问题， HTML5 提出了 Web Worker，允许主线程创建 Worker 线程，将一些任务分配给该线程在后台运行。JS 引擎线程与 Worker 线程之间通过 postMessage API 进行通信。

#### 事件触发线程

- 用来控制事件循环
- JS 引擎执行包含事件的代码块时，会将对应任务添加到事件线程中
- 当事件满足触发条件时，将其放入 JS 引擎所在的执行队列尾部，等待 JS 引擎处理

#### 定时触发器线程

- setInterval 与 setTimesout 所在的线程
- 计时完毕后通知事件触发线程

#### 异步 http 请求线程

- 在 XMLHttpRequest 连接后通过浏览器新开一个线程请求
- 检测到状态变更时，如果设置有回调函数，异步线程就会产生状态变更事件，将回调放入事件队列中，再由 JS 引擎执行

### 渲染流程

- 构建 DOM ：根据 HTML 渲染 DOM（同一个 HTML 文件得到的DOM 树并不总是一样，浏览器会按照自己的规范来构建）
- 加载次级资源：请求下载图片，CSS，JS 等资源
- JS 的下载与执行：`<script>`
- 样式计算：基于 CSS 选择器解析 CSS 计算每个节点的具体样式值
- 获取布局：遍历 DOM 以及相关元素的计算样式，构建出布局树
- 绘制各元素：遍历布局树，创建绘制记录
- 合成帧：遍历布局树，创建层树，合成器将每一层栅格化然后合成帧（合成器是独立工作的，与主线程无关，非常流畅）


[图解浏览器的基本工作原理](https://zhuanlan.zhihu.com/p/47407398)

[浏览器原理机制](https://www.jianshu.com/p/e05307cf8f6a)

[Web Worker 使用教程](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)

## 浏览器缓存

浏览器会把通过 HTTP 获取的所有资源保存到本地

### 缓存位置

Service Worker

memory cache | disk cache
--|--
缓存到内存中|缓存到磁盘中
退出进程时数据会被清除|退出进程时数据不会被清除

一般用 memory cache 保存 JS 文件

### 访问缓存优先级

1. 在内存中查找
2. 在硬盘中查找
3. 进行网络请求
4. 把获取的资源缓存到本地

### 强制缓存 和 协商缓存

浏览器子啊请求某一资源时，会先获取该资源缓存的 header 信息，判断是否命中强缓存，若命中则直接从缓存中获取资源信息，不会与服务器进行通信。若没有命中强缓存，浏览器会向服务器发送携带之前获取到的有关缓存的 header 信息，服务器对比相关 header 信息看是否命中协商缓存，若命中则服务器返回新的响应 header 信息更新缓存中对应的 header 信息，告知浏览器可以直接从缓存中获取资源信息，若没有命中协商缓存，则会直接返回最新的资源内容。

### Cache-Control

http 1.1 出现的 header 信息，

### Last-Modify

标识资源的最后修改时间，浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify。当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。

缺点：短时间内如果资源发生变化，Last-Modified 并不会变化，可以用 Etag 处理。

#### Etag

服务器针对资源计算出一串校验码，通过 Etag 返回给客户端，客户端下次请求时带上该值，服务器对比校验，如果相同则不返回资源。

[浅谈http中的Cache-Control](https://blog.csdn.net/u012375924/article/details/82806617)

[实践这一次，彻底搞懂浏览器缓存机制](https://segmentfault.com/a/1190000017962411) 这篇有些地方和我看到的其他文章有矛盾，之后有时间写一下


## 常见状态码

1xx表示信息，2xx表示成功，3xx表示重定向，4xx表示客户端错误，5xx表示服务端错误

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 301 moved permanently，永久重定向
- 302 found，临时重定向
- 304 not modified，表示服务器允许访问资源，但发送请求未满足条件
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 404 not found，表示在服务器上没有找到请求的资源
- 500 internal server error，表示服务器端在执行请求时发生了错误
- 503 service unavailable，表示服务器暂时处于超负载或正在停机维护，无法处理请求

## 跨域

协议、域名、端口任一不同就是跨域的

### 跨域出现的原因

JS 的同源策略：协议+主机号+端口相同才允许访问
在前后端分离的模式下，由于前后端域名不同会产生跨域问题（针对 JS 和 Ajax，HTML 没有跨域问题）

### 跨域的方法

- JSONP：创建一个 <script> 标签，src 指向响应方，只能用 get 方法
- CORS(Cross-origin resource sharing)：允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，克服了 Ajax 只能同源使用的限制。比 JSONP 强大，支持所有类型的 HTTP 请求
- 修改 document.domain 来跨子域：可以把 document.domain 设置成自身或更高一级的父域
- 使用 window.name 跨域：在一个 window 的生命周期内窗口载入的所有页面都是共享一个 window.name 的，每个页面对 window.name 都有读取权限，新页面的载入不会重置 window.name
- 使用 window.postMessage 跨域传送数据
- 服务器代理
- flash

[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

## window.location 和 window.history 在单页面中的应用（改变 URL 页面不刷新）

### API

- window.location
  - location.href
  - location.hash

- window.history
  - history.pushState()
  - history.replaceState()
  - history.go()
  - history.back()：相当于 history.go(-1)
  - history.forward()：相当于history.go(1)
  
### 监听 URL 变化

- hashchange：能监听 url hush 的改变
```
window.addEventListener('hashchange', function(e) {
  
})
```
- popstate：能监听除 history.pushState() 和 history.replaceState() 之外的 url 变化
```
window.addEventListener('popstate', function(e) {
  
})
```


