# 目录

# 正文

## 协议模型

OSI 七层模型 与 TCP/IP 五层模型的区别：OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络

### OSI 七层模型

从下到上：
1. 物理层：确定与传输媒体的接口的一些特性（EIA/TIA-232, EIA/TIA-499, V.35, 802.3）
2. 数据链路层：链路层协议，检测每一帧的信息（FDDI, Frame Relay, HDLC, SLIP, PPP）
3. 网络层：选择合适的网间路由和交换节点，确保数据按时成功传送（IP, ICMP, ARP, RARP, RIP, IPX）
4. 传输层：为两台主机进程之间的通信提供服务（TCP, UDP）
5. 会话层：负责建立、管理和终止表示层实体之间的通信会话（RPC, SQL, NFS, NetBIOS, names, AppleTalk）
6. 表示层：使通信的应用程序能够解释交换数据的含义（TIFF, GIF, JPEG, PICT）
7. 应用层：通过应用程序间的交互来完成特定的网络应用，需要各种协议（HTTP, TFTP, FTP, NFS, WAIS, SMTP, Telnet, DNS, SNMP）

### TCP/IP 五层模型

从下到上：
1. 物理层
2. 数据链路层
3. 网络层：互联网组管理协议 IGMP，互联网控制报文协议 ICMP
4. 传输层：TCP，UDP
5. 应用层：文件传输协议 FTP，Telnet，DNS，简单邮件传输协议 SMTP 

还有个 TCP/IP 四层模型，将数据链路层和物理层合并

TCP/IP 模型的应用层对应 OSI 模型的上面三层

数据的封装过程：应用层报文 - 传输层报文段 - 网络层 IP 分组 - 链路层添加 MAC 地址封装成数据帧 - 物理层比特流 - 通过传输介质传送到对端

## 应用层

### HTTP Hypertext Transfer Protocol 超文本传输协议 

组成：
- 起始行：报文描述
- 头部：报文属性
- 主体：报文数据

有两种连接模式，持续连接与非持续连接，持续链接下 TCP 默认不关闭，可以避免每次建立连接三次握手所花费的时间，非持续连接每次请求对象都需要建立一个全新的连接

#### HTTP 常见状态码

1xx表示信息响应
- 100	Continue，已收到请求，客户端应继续

2xx表示成功响应

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204	No Content，请求已处理，无返回，客户端不更新视图
- 205	Reset Content，请求已处理，无返回，客户端应更新视图

3xx表示重定向
- 301 Moved Permanently，永久重定向，默认可缓存，搜索引擎应更新链接
- 302 Found，临时重定向，默认不缓存，除非显示指定
- 304 Not Modified，未修改，不含响应体
- 307	Temporary Redirect，临时重定向，默认不缓存，除非显示指定，不改变请求方法和请求体
- 308	Permanent Redirect，永久重定向，默认可缓存，搜索引擎应更新链接，不改变请求方法和请求体

4xx表示客户端错误
- 400	Bad Request，请求语义或参数有误，不应重复请求
- 401 Unauthorized，请求需身份验证或验证失败
- 404 Not Found，未找到，无原因
- 408	Request Timeout，请求超时
- 410	Gone，资源已被永久移除
- 415	Unsupported Media Type，请求文件类型服务端不支持

5xx表示服务端错误
- 500 Internal Server Error，服务端报错，通常是脚本错误
- 502	Bad Gateway，网关无响应，通常是服务端环境配置错误
- 503 Service Unavailable，服务端临时不可用，建议返回Retry-After，搜索引擎爬虫应一段时间再次访问这个URL
- 504	Gateway Timeout，网关超时，通常是服务端过载
- 511	Network Authentication Required	需要身份验证，常见于公用 WIFI

#### HTTP 方法

- HTTP 1.0 ：GET，POST，HEAD 
- HTTP 1.1 ：OPTIONS，PUT, PATCH，DELETE，TRACE，CONNECT

##### GET 和 POST 区别

- GET：通常只用于读取数据，数据包含在 URL 中，只支持 URL 编码，提交的数据大小有限制（因浏览器而异）
- POST：可能会导致新的资源的建立或已有资源的更改，数据被包含在请求体中，支持多种编码格式，提交的数据没限制

#### Keep-Alive 和非 Keep-Alive 对服务器性能的影响

非 Keep-Alive 来说，必须为每一个请求的对象建立和维护一个全新的连接，每一个连接都需要客户机和服务器分配 TCP 的缓冲区和变量，会给服务器带来的严重的负担，在 Keep-Alive 方式下，服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。不过长时间保持 TCP 连接容易导致系统资源被无效占用，也会造成损失，重点是要恰当 Keep-Alive 模式配置

#### HTTP 版本

##### HTTP 1.0

无状态，无连接的应用层协议

- 无法复用连接
每次发送请求，都要新建连接

- 队头阻塞
下个请求必须在上个请求响应到达后发送。如果上个请求响应丢失，则后面请求被阻塞

##### HTTP 1.1

HTTP1.1 继承了 HTTP1.0 简单，克服了 HTTP1.0 性能上的问题

- 长连接
新增Connection: keep-alive保持永久连接

- 管道化
支持管道化请求，请求可以并行传输，但响应顺序应与请求顺序相同。实际场景中，浏览器采用建立多个TCP会话的方式，实现真正的并行，通过域名限制最大会话数量

- 缓存处理
新增Cache-control，支持强缓存和协商缓存

- 断点续传

- 主机头
新增Host字段，使得一个服务器创建多个站点

##### HTTP 2.0

HTTP2.0进一步改善了传输性能

- 二进制分帧
在应用层和传输层间增加二进制分帧层

- 多路复用
建立双向字节流，帧头部包含所属流 ID，帧可以乱序发送，数据流可设优先级和依赖。从而实现一个 TCP 会话上进行任意数量的HTTP请求，真正的并行传输

- 头部压缩
压缩算法编码原来纯文本发送的请求头，通讯双方各自缓存一份头部元数据表，避免传输重复头

- 服务器推送
服务端可主动向客户端推送资源，无需客户端请求

##### HTTP 3.0

当一个 TCP 会丢包时，整个会话都要等待重传，后面数据都被阻塞。这是由于 TCP 本身的局限性导致的。HTTP3.0 基于 UDP 协议，解决 TCP 的局限性

- 0-RTT
缓存当前会话上下文，下次恢复会话时，只需要将之前缓存传递给服务器，验证通过，即可传输数据

- 多路复用
一个会话的多个流间不存在依赖，丢包只需要重发包，不需要重传整个连接

- 更好的移动端表现
移动端 IP 经常变化，影响 TCP 传输，HTTP3.0 通过 ID 识别连接，只要 ID 不变，就能快速连接

- 加密认证的根文
TCP 协议头没有加密和认证，HTTP3.0 的包中几乎所有报文都要经过认证，主体经过加密，有效防窃听，注入和篡改

- 向前纠错机制
每个包还包含其他数据包的数据，少量丢包可通过其他包的冗余数据直接组装而无需重传。数据发送上限降低，但有效减少了丢包重传所需时间

#### cookie 与 session （会话跟踪技术）

HTTP 协议时无状态协议，数据交换完毕后就会关闭客户端与服务器端的连接，意味着服务器无法跟踪会话

-|cookie|session
存取位置|客户端|服务器端
存取值类型|字符串|大多数类型
大小|受客户端限制|自行配置
有效时间|写入时设置，用户可清除|自行配置，服务器端定时清除过期 session 防止内存溢出
跨域|可设置跨子域，不可跨主域|可跨域跨服务器

### HTTPS  Hyper Text Transfer Protocol over SecureSocket Layer 超文本传输安全协议

三次握手，使用 SSL/TLS 协议进行加密传输

- TSL 传输安全层协议：对称加密和非对称加密结合，数字证书

- SSL 安全套接字协议：对称算法，公用密钥算法

#### Socket

Socket是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议

#### Websocket

Websocket是html5提出的一个协议规范，是为解决客户端与服务端实时通信。本质上是一个基于tcp，先通过HTTP/HTTPS协议发起一条特殊的http请求进行握手后创建一个用于交换数据的TCP连接

WebSocket优势： 浏览器和服务器只需要要做一个握手的动作，在建立连接之后，双方可以在任意时刻，相互推送信息。同时，服务器与客户端之间交换的头信息很小

#### http 和 websocket 的长连接区别

HTTP1.1 通过使用 Connection:keep-alive 进行长连接，HTTP 1.1 默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。这种长连接是一种“伪链接”

websocket 的长连接，是一个真的全双工。长连接第一次 tcp 链路建立之后，后续数据可以双方都进行发送，不需要发送请求头

keep-alive 双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态

### HTTP 与 HTTPS 对比

项目|HTTP|HTTPS
--|--|--
默认端口|80|443
HTTP 版本|1.0 - 1.1|2 - 3
传输|明文，易被劫持|加密，不易劫持
CA 认证|不支持|支持
SEO|无优待|优先
页面响应速度|快，只需要三次握手|较慢，需要三次握手+SSL协商过程

### DNS Domain Name System 域名系统

用于 TCP/IP 网络，提供主机名到 IP 地址的转换服务

DNS 既使用 TCP 又使用 UDP，当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，当客户端向 DNS 服务器查询域名 ( 域名解析) 时会使用 UDP

#### 域名的层级结构

主机名.次级域名.顶级域名.根域名

host.sld.tld.root

#### DNS 查找过程

1. 在本地 host 文件、DNS 解析器缓存中查找主机 IP 地址
2. 到本地 DNS 服务器中查询
3. 到根域名服务器中查找顶级域名 IP 地址
4. 逐级向下返回直到找到主机 IP 地址

#### DNS 劫持

将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式

用户端的一些预防手段：

- 直接通过 IP 地址访问网站，避开 DNS 劫持
- 可以通过网络设置让 DNS 指向正常的域名服务器以实现对目的网址的正常访问，例如将计算机首选 DNS 服务器的地址固定为 8.8.8.8

### URI（统一资源标识符）和 URL（统一资源定位符）之间的区别

两者都定义了资源是什么，URL 是 URI 的一个子集，还定义了如何能访问到该资源

### 从 url 输入到页面展现发生了什么

1. 在浏览器中输入 url 
2. 应用层 DNS 解析域名：先本地查找，再查询 DNS 服务器
3. 应用层客户端发送 HTTP 请求
4. 传输层 TCP 传输报文：三次握手
5. 网络层 IP 协议查询 MAC 地址
6. 数据到达数据链路层
7. 服务器接受数据
8. 服务器响应请求
9. 服务器返回相应文件
10. 浏览器渲染



## 传输层

### TCP 三次握手 与 四次挥手

#### 三次握手（ TCP 连接的建立）

目的：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
1. 客户端向服务器发送一个 SYN 请求报文段，等待服务器确认
2. 服务器端收到 SYN 后，向客服端发送一个 ACK+SYN 报文确认连接请求
3. 客户端收到确认请求后，也向服务器端发送确认报文，然后客户端与服务器端都进入 ESTABLISHED 状态

#### 四次挥手 （TCP 连接的释放）

原因：TCP 连接是全双工通信的，单独一方释放连接只代表自己不能再向对方发送数据，需要双方都确认释放连接才可以

1. 客户端向服务器端发送一个 FIN 报文段，申请断开连接，不再发送数据，此时客户端仍可以接收数据
2. 服务器端接收到客户端的请求后，向客户端发送一个确认报文段，表示以后不再接受客户端发过来的数据。但此时还可以向客户端发送数据
3. 服务器端发送完所有数据后向客户端发送 FIN 报文段，申请断开连接，服务器端不再发送数据
4. 客户端接收到请求后，向服务器端发送一个确认应答，进入 TIME_WAIT 阶段，此阶段将持续一段时间（最大生存时间），如果这段时间内服务端没有重发请求，客户端将进入 CLOSED 状态，如果收到重发请求（确认报文丢失）就重发确认报文段，服务器端在收到确认报文后就会进入 CLOSED 状态

### TCP 协议 与 UDP 协议

### TCP 传输控制协议

- 面向连接，无差错、不丢失、不重复、按序到达的可靠交付
- 首部 20 字节
- 只支持一对一通信

### UDP 用户数据报协议

- 无连接，尽最大努力交付（不可靠）
- 首部 8 字节
- 支持一对一，一对多，多对一，多对多通信
- 实时性高，而且没有拥塞控制与流量控制机制，发送速率没有限制





## 网络层









## 数据链路层







## 网络安全问题







## 正向代理 与 反向代理

- 正向代理隐藏了真正的请求客户端，服务端只知道代理服务器是谁
- 反向代理隐藏了真正的服务端，客户端只知道代理服务器是谁，一般用来实现负载平衡



## 如何判断用户是否登录

用户输入的密码由 post 请求发送给服务器，服务器将其与自己数据库中的数据对比，不一致则返回信息给客户端，一致则生成一个 session，同时生成的 session ID 作为 cookie 发送给客户端，对比成功后就重定向至登陆前的页面。判断用户是否登录就是通过这个 session ID（session 过期 -> 登陆过期）






## 跨域

协议、域名、端口任一不同就是跨域的

### 跨域出现的原因

JS 的同源策略：协议+主机号+端口相同才允许访问

在前后端分离的模式下，由于前后端域名不同会产生跨域问题（针对 JS 和 Ajax，HTML 没有跨域问题）

### 跨域的方法

- JSONP：创建一个 <script> 标签，src 指向响应方，只能用 get 方法

- CORS(Cross-origin resource sharing)：允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，克服了 Ajax 只能同源使用的限制。比 JSONP 强大，支持所有类型的 HTTP 请求

- 修改 document.domain 来跨子域：可以把 document.domain 设置成自身或更高一级的父域

- 使用 window.name 跨域：在一个 window 的生命周期内窗口载入的所有页面都是共享一个 window.name 的，每个页面对 window.name 都有读取权限，新页面的载入不会重置 window.name

- 使用 window.postMessage 跨域传送数据

- 服务器代理

- flash

[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

## 单页面路由原理

History 模式则是利用了 HTML5 提供的 History API。在 BOM 模型下的 History 对象新增 pushState、replaceState 等 API，允许页面透过脚本操作浏览器的浏览记录而不需要真正的进行页面请求/刷新

![模式流程图](https://img-blog.csdnimg.cn/img_convert/e2c42493141ee3b5c5e28ae346cd1e8d.png)

参考资料：

[JS 前端路由：单页面应用的路由原理和实现](https://blog.csdn.net/weixin_44691608/article/details/115462057?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.control&spm=1001.2101.3001.4242)

## window.location 和 window.history 在单页面中的应用（改变 URL 页面不刷新）

### API

- window.location
  - location.href
  - location.hash

- window.history
  - history.pushState()
  - history.replaceState()
  - history.go()
  - history.back()：相当于 history.go(-1)
  - history.forward()：相当于history.go(1)
  
### 监听 URL 变化

- hashchange：能监听 url hush 的改变
```
window.addEventListener('hashchange', function(e) {
  
})
```
- popstate：能监听除 history.pushState() 和 history.replaceState() 之外的 url 变化
```
window.addEventListener('popstate', function(e) {
  
})
```